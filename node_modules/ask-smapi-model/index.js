"use strict";
/*
* Copyright 2019 Amazon.com, Inc. or its affiliates. All Rights Reserved.
*
* Licensed under the Apache License, Version 2.0 (the "License"). You may not use this file
* except in compliance with the License. A copy of the License is located at
*
* http://aws.amazon.com/apache2.0/
*
* or in the "license" file accompanying this file. This file is distributed on an "AS IS" BASIS,
* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for
* the specific language governing permissions and limitations under the License.
*/
var __extends = (this && this.__extends) || (function () {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var runtime = require("ask-sdk-model-runtime");
exports.runtime = runtime;
var BaseServiceClient = runtime.BaseServiceClient;
var LwaServiceClient = runtime.LwaServiceClient;
var createUserAgent = runtime.createUserAgent;
var services;
(function (services) {
    var skillManagement;
    (function (skillManagement) {
        /**
         *
         */
        var SkillManagementServiceClient = /** @class */ (function (_super) {
            __extends(SkillManagementServiceClient, _super);
            function SkillManagementServiceClient(apiConfiguration, authenticationConfiguration, customUserAgent) {
                if (customUserAgent === void 0) { customUserAgent = null; }
                var _this = _super.call(this, apiConfiguration) || this;
                _this.lwaServiceClient = new LwaServiceClient({
                    apiConfiguration: apiConfiguration,
                    authenticationConfiguration: authenticationConfiguration,
                    grantType: 'refresh_token',
                });
                _this.userAgent = createUserAgent("" + require('./package.json').version, customUserAgent);
                return _this;
            }
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             */
            SkillManagementServiceClient.prototype.callGetCatalogV0 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetCatalogV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/catalogs/{catalogId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             */
            SkillManagementServiceClient.prototype.getCatalogV0 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetCatalogV0(catalogId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListUploadsForCatalogV0 = function (catalogId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListUploadsForCatalogV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/catalogs/{catalogId}/uploads";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listUploadsForCatalogV0 = function (catalogId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListUploadsForCatalogV0(catalogId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v0.catalog.upload.CreateContentUploadRequest} createContentUploadRequest Defines the request body for updateCatalog API.
             */
            SkillManagementServiceClient.prototype.callCreateContentUploadV0 = function (catalogId, createContentUploadRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateContentUploadV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'createContentUploadRequest' is not null or undefined
                                if (createContentUploadRequest == null) {
                                    throw new Error("Required parameter createContentUploadRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/catalogs/{catalogId}/uploads";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Content upload created.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createContentUploadRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v0.catalog.upload.CreateContentUploadRequest} createContentUploadRequest Defines the request body for updateCatalog API.
             */
            SkillManagementServiceClient.prototype.createContentUploadV0 = function (catalogId, createContentUploadRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateContentUploadV0(catalogId, createContentUploadRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} uploadId Unique identifier of the upload
             */
            SkillManagementServiceClient.prototype.callGetContentUploadByIdV0 = function (catalogId, uploadId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetContentUploadByIdV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'uploadId' is not null or undefined
                                if (uploadId == null) {
                                    throw new Error("Required parameter uploadId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('uploadId', uploadId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/catalogs/{catalogId}/uploads/{uploadId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} uploadId Unique identifier of the upload
             */
            SkillManagementServiceClient.prototype.getContentUploadByIdV0 = function (catalogId, uploadId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetContentUploadByIdV0(catalogId, uploadId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} uploadId Unique identifier of the upload
             * @param {v0.catalog.upload.CompleteUploadRequest} completeUploadRequestPayload Request payload to complete an upload.
             */
            SkillManagementServiceClient.prototype.callCompleteCatalogUploadV0 = function (catalogId, uploadId, completeUploadRequestPayload) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCompleteCatalogUploadV0';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'uploadId' is not null or undefined
                                if (uploadId == null) {
                                    throw new Error("Required parameter uploadId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'completeUploadRequestPayload' is not null or undefined
                                if (completeUploadRequestPayload == null) {
                                    throw new Error("Required parameter completeUploadRequestPayload was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('uploadId', uploadId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/catalogs/{catalogId}/uploads/{uploadId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, completeUploadRequestPayload, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} uploadId Unique identifier of the upload
             * @param {v0.catalog.upload.CompleteUploadRequest} completeUploadRequestPayload Request payload to complete an upload.
             */
            SkillManagementServiceClient.prototype.completeCatalogUploadV0 = function (catalogId, uploadId, completeUploadRequestPayload) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCompleteCatalogUploadV0(catalogId, uploadId, completeUploadRequestPayload)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListCatalogsForVendorV0 = function (vendorId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListCatalogsForVendorV0';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                queryParams.push({ key: 'vendorId', value: vendorId });
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listCatalogsForVendorV0 = function (vendorId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListCatalogsForVendorV0(vendorId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v0.catalog.CreateCatalogRequest} createCatalogRequest Defines the request body for createCatalog API.
             */
            SkillManagementServiceClient.prototype.callCreateCatalogV0 = function (createCatalogRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateCatalogV0';
                                // verify required parameter 'createCatalogRequest' is not null or undefined
                                if (createCatalogRequest == null) {
                                    throw new Error("Required parameter createCatalogRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Catalog created.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createCatalogRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v0.catalog.CreateCatalogRequest} createCatalogRequest Defines the request body for createCatalog API.
             */
            SkillManagementServiceClient.prototype.createCatalogV0 = function (createCatalogRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateCatalogV0(createCatalogRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListSubscribersForDevelopmentEventsV0 = function (vendorId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListSubscribersForDevelopmentEventsV0';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                queryParams.push({ key: 'vendorId', value: vendorId });
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscribers";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listSubscribersForDevelopmentEventsV0 = function (vendorId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListSubscribersForDevelopmentEventsV0(vendorId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v0.developmentEvents.subscriber.CreateSubscriberRequest} createSubscriberRequest Defines the request body for createSubscriber API.
             */
            SkillManagementServiceClient.prototype.callCreateSubscriberForDevelopmentEventsV0 = function (createSubscriberRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSubscriberForDevelopmentEventsV0';
                                // verify required parameter 'createSubscriberRequest' is not null or undefined
                                if (createSubscriberRequest == null) {
                                    throw new Error("Required parameter createSubscriberRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscribers";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Created. Returns a URL to retrieve the subscriber in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createSubscriberRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v0.developmentEvents.subscriber.CreateSubscriberRequest} createSubscriberRequest Defines the request body for createSubscriber API.
             */
            SkillManagementServiceClient.prototype.createSubscriberForDevelopmentEventsV0 = function (createSubscriberRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSubscriberForDevelopmentEventsV0(createSubscriberRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriberId Unique identifier of the subscriber.
             */
            SkillManagementServiceClient.prototype.callDeleteSubscriberForDevelopmentEventsV0 = function (subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteSubscriberForDevelopmentEventsV0';
                                // verify required parameter 'subscriberId' is not null or undefined
                                if (subscriberId == null) {
                                    throw new Error("Required parameter subscriberId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriberId', subscriberId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscribers/{subscriberId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriberId Unique identifier of the subscriber.
             */
            SkillManagementServiceClient.prototype.deleteSubscriberForDevelopmentEventsV0 = function (subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteSubscriberForDevelopmentEventsV0(subscriberId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriberId Unique identifier of the subscriber.
             */
            SkillManagementServiceClient.prototype.callGetSubscriberForDevelopmentEventsV0 = function (subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSubscriberForDevelopmentEventsV0';
                                // verify required parameter 'subscriberId' is not null or undefined
                                if (subscriberId == null) {
                                    throw new Error("Required parameter subscriberId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriberId', subscriberId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscribers/{subscriberId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriberId Unique identifier of the subscriber.
             */
            SkillManagementServiceClient.prototype.getSubscriberForDevelopmentEventsV0 = function (subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSubscriberForDevelopmentEventsV0(subscriberId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriberId Unique identifier of the subscriber.
             * @param {v0.developmentEvents.subscriber.UpdateSubscriberRequest} updateSubscriberRequest Defines the request body for updateSubscriber API.
             */
            SkillManagementServiceClient.prototype.callSetSubscriberForDevelopmentEventsV0 = function (subscriberId, updateSubscriberRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetSubscriberForDevelopmentEventsV0';
                                // verify required parameter 'subscriberId' is not null or undefined
                                if (subscriberId == null) {
                                    throw new Error("Required parameter subscriberId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateSubscriberRequest' is not null or undefined
                                if (updateSubscriberRequest == null) {
                                    throw new Error("Required parameter updateSubscriberRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriberId', subscriberId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscribers/{subscriberId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateSubscriberRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriberId Unique identifier of the subscriber.
             * @param {v0.developmentEvents.subscriber.UpdateSubscriberRequest} updateSubscriberRequest Defines the request body for updateSubscriber API.
             */
            SkillManagementServiceClient.prototype.setSubscriberForDevelopmentEventsV0 = function (subscriberId, updateSubscriberRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetSubscriberForDevelopmentEventsV0(subscriberId, updateSubscriberRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} subscriberId Unique identifier of the subscriber. If this query parameter is provided, the list would be filtered by the owning subscriberId.
             */
            SkillManagementServiceClient.prototype.callListSubscriptionsForDevelopmentEventsV0 = function (vendorId, nextToken, maxResults, subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListSubscriptionsForDevelopmentEventsV0';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                queryParams.push({ key: 'vendorId', value: vendorId });
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (subscriberId != null) {
                                    queryParams.push({ key: 'subscriberId', value: subscriberId });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscriptions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} subscriberId Unique identifier of the subscriber. If this query parameter is provided, the list would be filtered by the owning subscriberId.
             */
            SkillManagementServiceClient.prototype.listSubscriptionsForDevelopmentEventsV0 = function (vendorId, nextToken, maxResults, subscriberId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListSubscriptionsForDevelopmentEventsV0(vendorId, nextToken, maxResults, subscriberId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v0.developmentEvents.subscription.CreateSubscriptionRequest} createSubscriptionRequest Request body for createSubscription API.
             */
            SkillManagementServiceClient.prototype.callCreateSubscriptionForDevelopmentEventsV0 = function (createSubscriptionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSubscriptionForDevelopmentEventsV0';
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscriptions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Created; Returns a URL to retrieve the subscription in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createSubscriptionRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v0.developmentEvents.subscription.CreateSubscriptionRequest} createSubscriptionRequest Request body for createSubscription API.
             */
            SkillManagementServiceClient.prototype.createSubscriptionForDevelopmentEventsV0 = function (createSubscriptionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSubscriptionForDevelopmentEventsV0(createSubscriptionRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriptionId Unique identifier of the subscription.
             */
            SkillManagementServiceClient.prototype.callDeleteSubscriptionForDevelopmentEventsV0 = function (subscriptionId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteSubscriptionForDevelopmentEventsV0';
                                // verify required parameter 'subscriptionId' is not null or undefined
                                if (subscriptionId == null) {
                                    throw new Error("Required parameter subscriptionId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriptionId', subscriptionId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscriptions/{subscriptionId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriptionId Unique identifier of the subscription.
             */
            SkillManagementServiceClient.prototype.deleteSubscriptionForDevelopmentEventsV0 = function (subscriptionId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteSubscriptionForDevelopmentEventsV0(subscriptionId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriptionId Unique identifier of the subscription.
             */
            SkillManagementServiceClient.prototype.callGetSubscriptionForDevelopmentEventsV0 = function (subscriptionId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSubscriptionForDevelopmentEventsV0';
                                // verify required parameter 'subscriptionId' is not null or undefined
                                if (subscriptionId == null) {
                                    throw new Error("Required parameter subscriptionId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriptionId', subscriptionId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscriptions/{subscriptionId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriptionId Unique identifier of the subscription.
             */
            SkillManagementServiceClient.prototype.getSubscriptionForDevelopmentEventsV0 = function (subscriptionId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSubscriptionForDevelopmentEventsV0(subscriptionId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriptionId Unique identifier of the subscription.
             * @param {v0.developmentEvents.subscription.UpdateSubscriptionRequest} updateSubscriptionRequest Request body for updateSubscription API.
             */
            SkillManagementServiceClient.prototype.callSetSubscriptionForDevelopmentEventsV0 = function (subscriptionId, updateSubscriptionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetSubscriptionForDevelopmentEventsV0';
                                // verify required parameter 'subscriptionId' is not null or undefined
                                if (subscriptionId == null) {
                                    throw new Error("Required parameter subscriptionId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('subscriptionId', subscriptionId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/developmentEvents/subscriptions/{subscriptionId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateSubscriptionRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} subscriptionId Unique identifier of the subscription.
             * @param {v0.developmentEvents.subscription.UpdateSubscriptionRequest} updateSubscriptionRequest Request body for updateSubscription API.
             */
            SkillManagementServiceClient.prototype.setSubscriptionForDevelopmentEventsV0 = function (subscriptionId, updateSubscriptionRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetSubscriptionForDevelopmentEventsV0(subscriptionId, updateSubscriptionRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} catalogId Provides a unique identifier of the catalog
             */
            SkillManagementServiceClient.prototype.callAssociateCatalogWithSkillV0 = function (skillId, catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callAssociateCatalogWithSkillV0';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/skills/{skillId}/catalogs/{catalogId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} catalogId Provides a unique identifier of the catalog
             */
            SkillManagementServiceClient.prototype.associateCatalogWithSkillV0 = function (skillId, catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callAssociateCatalogWithSkillV0(skillId, catalogId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListCatalogsForSkillV0 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListCatalogsForSkillV0';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v0/skills/{skillId}/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listCatalogsForSkillV0 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListCatalogsForSkillV0(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v1.catalog.upload.CatalogUploadBase} catalogUploadRequestBody Provides the request body for create content upload
             */
            SkillManagementServiceClient.prototype.callCreateCatalogUploadV1 = function (catalogId, catalogUploadRequestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateCatalogUploadV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'catalogUploadRequestBody' is not null or undefined
                                if (catalogUploadRequestBody == null) {
                                    throw new Error("Required parameter catalogUploadRequestBody was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/catalogs/{catalogId}/uploads";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId. ");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, catalogUploadRequestBody, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v1.catalog.upload.CatalogUploadBase} catalogUploadRequestBody Provides the request body for create content upload
             */
            SkillManagementServiceClient.prototype.createCatalogUploadV1 = function (catalogId, catalogUploadRequestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateCatalogUploadV1(catalogId, catalogUploadRequestBody)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} uploadId Unique identifier of the upload
             */
            SkillManagementServiceClient.prototype.callGetContentUploadByIdV1 = function (catalogId, uploadId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetContentUploadByIdV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'uploadId' is not null or undefined
                                if (uploadId == null) {
                                    throw new Error("Required parameter uploadId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('uploadId', uploadId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/catalogs/{catalogId}/uploads/{uploadId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successful operation.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId. ");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} uploadId Unique identifier of the upload
             */
            SkillManagementServiceClient.prototype.getContentUploadByIdV1 = function (catalogId, uploadId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetContentUploadByIdV1(catalogId, uploadId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v1.catalog.CreateContentUploadUrlRequest} generateCatalogUploadUrlRequestBody Request body to generate catalog upload url
             */
            SkillManagementServiceClient.prototype.callGenerateCatalogUploadUrlV1 = function (catalogId, generateCatalogUploadUrlRequestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGenerateCatalogUploadUrlV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'generateCatalogUploadUrlRequestBody' is not null or undefined
                                if (generateCatalogUploadUrlRequestBody == null) {
                                    throw new Error("Required parameter generateCatalogUploadUrlRequestBody was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/catalogs/{catalogId}/urls";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Successful operation.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, generateCatalogUploadUrlRequestBody, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v1.catalog.CreateContentUploadUrlRequest} generateCatalogUploadUrlRequestBody Request body to generate catalog upload url
             */
            SkillManagementServiceClient.prototype.generateCatalogUploadUrlV1 = function (catalogId, generateCatalogUploadUrlRequestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGenerateCatalogUploadUrlV1(catalogId, generateCatalogUploadUrlRequestBody)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.auditLogs.AuditLogsRequest} getAuditLogsRequest Request object encompassing vendorId, optional request filters and optional pagination context.
             */
            SkillManagementServiceClient.prototype.callQueryDevelopmentAuditLogsV1 = function (getAuditLogsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callQueryDevelopmentAuditLogsV1';
                                // verify required parameter 'getAuditLogsRequest' is not null or undefined
                                if (getAuditLogsRequest == null) {
                                    throw new Error("Required parameter getAuditLogsRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/developmentAuditLogs/query";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns a list of audit logs for the given vendor.");
                                errorDefinitions.set(400, "Invalid request");
                                errorDefinitions.set(401, "Unauthorized");
                                errorDefinitions.set(403, "Forbidden");
                                errorDefinitions.set(404, "Not Found");
                                errorDefinitions.set(429, "Too Many Requests");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, getAuditLogsRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.auditLogs.AuditLogsRequest} getAuditLogsRequest Request object encompassing vendorId, optional request filters and optional pagination context.
             */
            SkillManagementServiceClient.prototype.queryDevelopmentAuditLogsV1 = function (getAuditLogsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callQueryDevelopmentAuditLogsV1(getAuditLogsRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {Array<string>} productId The list of in-skill product IDs that you wish to get the summary for. A maximum of 50 in-skill product IDs can be specified in a single listInSkillProducts call. Please note that this parameter must not be used with &#39;nextToken&#39; and/or &#39;maxResults&#39; parameter.
             * @param {string} stage Filter in-skill products by specified stage.
             * @param {string} type Type of in-skill product to filter on.
             * @param {string} referenceName Filter in-skill products by reference name.
             * @param {string} status Status of in-skill product.
             * @param {string} isAssociatedWithSkill Filter in-skill products by whether or not they are associated to a skill.
             */
            SkillManagementServiceClient.prototype.callGetIspListForVendorV1 = function (vendorId, nextToken, maxResults, productId, stage, type, referenceName, status, isAssociatedWithSkill) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspListForVendorV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                queryParams.push({ key: 'vendorId', value: vendorId });
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (productId != null) {
                                    queryParams.push({ key: 'productId', value: productId.toString() });
                                }
                                if (stage != null) {
                                    queryParams.push({ key: 'stage', value: stage });
                                }
                                if (type != null) {
                                    queryParams.push({ key: 'type', value: type });
                                }
                                if (referenceName != null) {
                                    queryParams.push({ key: 'referenceName', value: referenceName });
                                }
                                if (status != null) {
                                    queryParams.push({ key: 'status', value: status });
                                }
                                if (isAssociatedWithSkill != null) {
                                    queryParams.push({ key: 'isAssociatedWithSkill', value: isAssociatedWithSkill });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains list of in-skill products for the specified vendor and stage.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {Array<string>} productId The list of in-skill product IDs that you wish to get the summary for. A maximum of 50 in-skill product IDs can be specified in a single listInSkillProducts call. Please note that this parameter must not be used with &#39;nextToken&#39; and/or &#39;maxResults&#39; parameter.
             * @param {string} stage Filter in-skill products by specified stage.
             * @param {string} type Type of in-skill product to filter on.
             * @param {string} referenceName Filter in-skill products by reference name.
             * @param {string} status Status of in-skill product.
             * @param {string} isAssociatedWithSkill Filter in-skill products by whether or not they are associated to a skill.
             */
            SkillManagementServiceClient.prototype.getIspListForVendorV1 = function (vendorId, nextToken, maxResults, productId, stage, type, referenceName, status, isAssociatedWithSkill) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspListForVendorV1(vendorId, nextToken, maxResults, productId, stage, type, referenceName, status, isAssociatedWithSkill)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.isp.CreateInSkillProductRequest} createInSkillProductRequest defines the request body for createInSkillProduct API.
             */
            SkillManagementServiceClient.prototype.callCreateIspForVendorV1 = function (createInSkillProductRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateIspForVendorV1';
                                // verify required parameter 'createInSkillProductRequest' is not null or undefined
                                if (createInSkillProductRequest == null) {
                                    throw new Error("Required parameter createInSkillProductRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Success.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createInSkillProductRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.isp.CreateInSkillProductRequest} createInSkillProductRequest defines the request body for createInSkillProduct API.
             */
            SkillManagementServiceClient.prototype.createIspForVendorV1 = function (createInSkillProductRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateIspForVendorV1(createInSkillProductRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callDisassociateIspWithSkillV1 = function (productId, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDisassociateIspWithSkillV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts/{productId}/skills/{skillId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.disassociateIspWithSkillV1 = function (productId, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDisassociateIspWithSkillV1(productId, skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callAssociateIspWithSkillV1 = function (productId, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callAssociateIspWithSkillV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts/{productId}/skills/{skillId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.associateIspWithSkillV1 = function (productId, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callAssociateIspWithSkillV1(productId, skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callDeleteIspForProductV1 = function (productId, stage, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteIspForProductV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts/{productId}/stages/{stage}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.deleteIspForProductV1 = function (productId, stage, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteIspForProductV1(productId, stage, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callResetEntitlementForProductV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callResetEntitlementForProductV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts/{productId}/stages/{stage}/entitlement";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.resetEntitlementForProductV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callResetEntitlementForProductV1(productId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callGetIspDefinitionV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspDefinitionV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts/{productId}/stages/{stage}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the latest version of an in-skill product for the specified stage.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.getIspDefinitionV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspDefinitionV1(productId, stage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {v1.isp.UpdateInSkillProductRequest} updateInSkillProductRequest defines the request body for updateInSkillProduct API.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callUpdateIspForProductV1 = function (productId, stage, updateInSkillProductRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateIspForProductV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateInSkillProductRequest' is not null or undefined
                                if (updateInSkillProductRequest == null) {
                                    throw new Error("Required parameter updateInSkillProductRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts/{productId}/stages/{stage}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "Request is forbidden.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateInSkillProductRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {v1.isp.UpdateInSkillProductRequest} updateInSkillProductRequest defines the request body for updateInSkillProduct API.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.updateIspForProductV1 = function (productId, stage, updateInSkillProductRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateIspForProductV1(productId, stage, updateInSkillProductRequest, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callGetIspAssociatedSkillsV1 = function (productId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspAssociatedSkillsV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts/{productId}/stages/{stage}/skills";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns skills associated with the in-skill product.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.getIspAssociatedSkillsV1 = function (productId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspAssociatedSkillsV1(productId, stage, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callGetIspSummaryV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspSummaryV1';
                                // verify required parameter 'productId' is not null or undefined
                                if (productId == null) {
                                    throw new Error("Required parameter productId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('productId', productId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/inSkillProducts/{productId}/stages/{stage}/summary";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns current in-skill product summary for productId.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} productId The in-skill product ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.getIspSummaryV1 = function (productId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspSummaryV1(productId, stage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             */
            SkillManagementServiceClient.prototype.callDeleteInteractionModelCatalogV1 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteInteractionModelCatalogV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content; just confirm the catalog is deleted.");
                                errorDefinitions.set(400, "The catalog cannot be deleted from reasons due to in-use by other entities.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             */
            SkillManagementServiceClient.prototype.deleteInteractionModelCatalogV1 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteInteractionModelCatalogV1(catalogId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelCatalogDefinitionV1 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelCatalogDefinitionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "the catalog definition");
                                errorDefinitions.set(400, "The catalog cannot be retrieved due to errors listed.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             */
            SkillManagementServiceClient.prototype.getInteractionModelCatalogDefinitionV1 = function (catalogId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelCatalogDefinitionV1(catalogId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v1.skill.interactionModel.type.UpdateRequest} updateRequest
             */
            SkillManagementServiceClient.prototype.callUpdateInteractionModelCatalogV1 = function (catalogId, updateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateInteractionModelCatalogV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateRequest' is not null or undefined
                                if (updateRequest == null) {
                                    throw new Error("Required parameter updateRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/update";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content, indicates the fields were successfully updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v1.skill.interactionModel.type.UpdateRequest} updateRequest
             */
            SkillManagementServiceClient.prototype.updateInteractionModelCatalogV1 = function (catalogId, updateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateInteractionModelCatalogV1(catalogId, updateRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} updateRequestId The identifier for slotType version creation process
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelCatalogUpdateStatusV1 = function (catalogId, updateRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelCatalogUpdateStatusV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateRequestId' is not null or undefined
                                if (updateRequestId == null) {
                                    throw new Error("Required parameter updateRequestId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('updateRequestId', updateRequestId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/updateRequest/{updateRequestId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the build status and error codes for the given catalogId");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} updateRequestId The identifier for slotType version creation process
             */
            SkillManagementServiceClient.prototype.getInteractionModelCatalogUpdateStatusV1 = function (catalogId, updateRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelCatalogUpdateStatusV1(catalogId, updateRequestId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v1.skill.interactionModel.version.VersionData} catalog
             */
            SkillManagementServiceClient.prototype.callCreateInteractionModelCatalogVersionV1 = function (catalogId, catalog) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateInteractionModelCatalogVersionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'catalog' is not null or undefined
                                if (catalog == null) {
                                    throw new Error("Required parameter catalog was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Returns update status location link on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the catalog definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified catalog does not exist.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, catalog, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {v1.skill.interactionModel.version.VersionData} catalog
             */
            SkillManagementServiceClient.prototype.createInteractionModelCatalogVersionV1 = function (catalogId, catalog) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateInteractionModelCatalogVersionV1(catalogId, catalog)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callDeleteInteractionModelCatalogVersionV1 = function (catalogId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteInteractionModelCatalogVersionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that version is successfully deleted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog version for this catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.deleteInteractionModelCatalogVersionV1 = function (catalogId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteInteractionModelCatalogVersionV1(catalogId, version)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelCatalogVersionV1 = function (catalogId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelCatalogVersionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the catalog version metadata for the given catalogId and version.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.getInteractionModelCatalogVersionV1 = function (catalogId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelCatalogVersionV1(catalogId, version)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} version Version for interaction model.
             * @param {v1.skill.interactionModel.version.CatalogUpdate} catalogUpdate
             */
            SkillManagementServiceClient.prototype.callUpdateInteractionModelCatalogVersionV1 = function (catalogId, version, catalogUpdate) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateInteractionModelCatalogVersionV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions/{version}/update";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that version is successfully updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, catalogUpdate, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} version Version for interaction model.
             * @param {v1.skill.interactionModel.version.CatalogUpdate} catalogUpdate
             */
            SkillManagementServiceClient.prototype.updateInteractionModelCatalogVersionV1 = function (catalogId, version, catalogUpdate) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateInteractionModelCatalogVersionV1(catalogId, version, catalogUpdate)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} version Version for interaction model.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelCatalogValuesV1 = function (catalogId, version, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelCatalogValuesV1';
                                // verify required parameter 'catalogId' is not null or undefined
                                if (catalogId == null) {
                                    throw new Error("Required parameter catalogId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('catalogId', catalogId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs/{catalogId}/versions/{version}/values";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of catalog values for the given catalogId and version.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} catalogId Provides a unique identifier of the catalog
             * @param {string} version Version for interaction model.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.getInteractionModelCatalogValuesV1 = function (catalogId, version, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelCatalogValuesV1(catalogId, version, maxResults, nextToken)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelCatalogsV1 = function (vendorId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelCatalogsV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                queryParams.push({ key: 'vendorId', value: vendorId });
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (sortDirection != null) {
                                    queryParams.push({ key: 'sortDirection', value: sortDirection });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of catalogs for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.listInteractionModelCatalogsV1 = function (vendorId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelCatalogsV1(vendorId, maxResults, nextToken, sortDirection)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.interactionModel.catalog.DefinitionData} catalog
             */
            SkillManagementServiceClient.prototype.callCreateInteractionModelCatalogV1 = function (catalog) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateInteractionModelCatalogV1';
                                // verify required parameter 'catalog' is not null or undefined
                                if (catalog == null) {
                                    throw new Error("Required parameter catalog was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/catalogs";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the generated catalogId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the catalog definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, catalog, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.interactionModel.catalog.DefinitionData} catalog
             */
            SkillManagementServiceClient.prototype.createInteractionModelCatalogV1 = function (catalog) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateInteractionModelCatalogV1(catalog)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelSlotTypesV1 = function (vendorId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelSlotTypesV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                queryParams.push({ key: 'vendorId', value: vendorId });
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (sortDirection != null) {
                                    queryParams.push({ key: 'sortDirection', value: sortDirection });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of slot types for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.listInteractionModelSlotTypesV1 = function (vendorId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelSlotTypesV1(vendorId, maxResults, nextToken, sortDirection)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.interactionModel.type.DefinitionData} slotType
             */
            SkillManagementServiceClient.prototype.callCreateInteractionModelSlotTypeV1 = function (slotType) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateInteractionModelSlotTypeV1';
                                // verify required parameter 'slotType' is not null or undefined
                                if (slotType == null) {
                                    throw new Error("Required parameter slotType was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the generated slotTypeId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the slot type definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, slotType, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.interactionModel.type.DefinitionData} slotType
             */
            SkillManagementServiceClient.prototype.createInteractionModelSlotTypeV1 = function (slotType) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateInteractionModelSlotTypeV1(slotType)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             */
            SkillManagementServiceClient.prototype.callDeleteInteractionModelSlotTypeV1 = function (slotTypeId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteInteractionModelSlotTypeV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content; just confirm the slot type is deleted.");
                                errorDefinitions.set(400, "The slot type cannot be deleted from reasons due to in-use by other entities.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             */
            SkillManagementServiceClient.prototype.deleteInteractionModelSlotTypeV1 = function (slotTypeId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteInteractionModelSlotTypeV1(slotTypeId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelSlotTypeDefinitionV1 = function (slotTypeId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelSlotTypeDefinitionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The slot type definition.");
                                errorDefinitions.set(400, "The slot type cannot be retrieved due to errors listed.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             */
            SkillManagementServiceClient.prototype.getInteractionModelSlotTypeDefinitionV1 = function (slotTypeId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelSlotTypeDefinitionV1(slotTypeId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {v1.skill.interactionModel.type.UpdateRequest} updateRequest
             */
            SkillManagementServiceClient.prototype.callUpdateInteractionModelSlotTypeV1 = function (slotTypeId, updateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateInteractionModelSlotTypeV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateRequest' is not null or undefined
                                if (updateRequest == null) {
                                    throw new Error("Required parameter updateRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/update";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No content, indicates the fields were successfully updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {v1.skill.interactionModel.type.UpdateRequest} updateRequest
             */
            SkillManagementServiceClient.prototype.updateInteractionModelSlotTypeV1 = function (slotTypeId, updateRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateInteractionModelSlotTypeV1(slotTypeId, updateRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} updateRequestId The identifier for slotType version creation process
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelSlotTypeBuildStatusV1 = function (slotTypeId, updateRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelSlotTypeBuildStatusV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateRequestId' is not null or undefined
                                if (updateRequestId == null) {
                                    throw new Error("Required parameter updateRequestId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                pathParams.set('updateRequestId', updateRequestId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/updateRequest/{updateRequestId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the build status and error codes for the given slotTypeId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} updateRequestId The identifier for slotType version creation process
             */
            SkillManagementServiceClient.prototype.getInteractionModelSlotTypeBuildStatusV1 = function (slotTypeId, updateRequestId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelSlotTypeBuildStatusV1(slotTypeId, updateRequestId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelSlotTypeVersionsV1 = function (slotTypeId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelSlotTypeVersionsV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (sortDirection != null) {
                                    queryParams.push({ key: 'sortDirection', value: sortDirection });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of slot type version for the slot type id.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             */
            SkillManagementServiceClient.prototype.listInteractionModelSlotTypeVersionsV1 = function (slotTypeId, maxResults, nextToken, sortDirection) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelSlotTypeVersionsV1(slotTypeId, maxResults, nextToken, sortDirection)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {v1.skill.interactionModel.typeVersion.VersionData} slotType
             */
            SkillManagementServiceClient.prototype.callCreateInteractionModelSlotTypeVersionV1 = function (slotTypeId, slotType) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateInteractionModelSlotTypeVersionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'slotType' is not null or undefined
                                if (slotType == null) {
                                    throw new Error("Required parameter slotType was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Returns update status location link on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the slot type definition is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified slot type does not exist.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, slotType, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {v1.skill.interactionModel.typeVersion.VersionData} slotType
             */
            SkillManagementServiceClient.prototype.createInteractionModelSlotTypeVersionV1 = function (slotTypeId, slotType) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateInteractionModelSlotTypeVersionV1(slotTypeId, slotType)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callDeleteInteractionModelSlotTypeVersionV1 = function (slotTypeId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteInteractionModelSlotTypeVersionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that version is successfully deleted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type version for this slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.deleteInteractionModelSlotTypeVersionV1 = function (slotTypeId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteInteractionModelSlotTypeVersionV1(slotTypeId, version)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelSlotTypeVersionV1 = function (slotTypeId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelSlotTypeVersionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns the slot type version metadata for the given slotTypeId and version.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.getInteractionModelSlotTypeVersionV1 = function (slotTypeId, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelSlotTypeVersionV1(slotTypeId, version)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             * @param {v1.skill.interactionModel.typeVersion.SlotTypeUpdate} slotTypeUpdate
             */
            SkillManagementServiceClient.prototype.callUpdateInteractionModelSlotTypeVersionV1 = function (slotTypeId, version, slotTypeUpdate) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateInteractionModelSlotTypeVersionV1';
                                // verify required parameter 'slotTypeId' is not null or undefined
                                if (slotTypeId == null) {
                                    throw new Error("Required parameter slotTypeId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'slotTypeUpdate' is not null or undefined
                                if (slotTypeUpdate == null) {
                                    throw new Error("Required parameter slotTypeUpdate was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('slotTypeId', slotTypeId);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/api/custom/interactionModel/slotTypes/{slotTypeId}/versions/{version}/update";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that version is successfully updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no slot type defined for the slotTypeId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, slotTypeUpdate, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} slotTypeId The identifier for a slot type.
             * @param {string} version Version for interaction model.
             * @param {v1.skill.interactionModel.typeVersion.SlotTypeUpdate} slotTypeUpdate
             */
            SkillManagementServiceClient.prototype.updateInteractionModelSlotTypeVersionV1 = function (slotTypeId, version, slotTypeUpdate) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateInteractionModelSlotTypeVersionV1(slotTypeId, version, slotTypeUpdate)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} exportId The Export ID.
             */
            SkillManagementServiceClient.prototype.callGetStatusOfExportRequestV1 = function (exportId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetStatusOfExportRequestV1';
                                // verify required parameter 'exportId' is not null or undefined
                                if (exportId == null) {
                                    throw new Error("Required parameter exportId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('exportId', exportId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/exports/{exportId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "OK.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} exportId The Export ID.
             */
            SkillManagementServiceClient.prototype.getStatusOfExportRequestV1 = function (exportId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetStatusOfExportRequestV1(exportId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {Array<string>} skillId the list of skillIds that you wish to get the summary for. A maximum of 10 skillIds can be specified to get the skill summary in single listSkills call. Please note that this parameter must not be used with &#39;nextToken&#39; or/and &#39;maxResults&#39; parameter.
             */
            SkillManagementServiceClient.prototype.callListSkillsForVendorV1 = function (vendorId, nextToken, maxResults, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListSkillsForVendorV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                queryParams.push({ key: 'vendorId', value: vendorId });
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (skillId != null) {
                                    queryParams.push({ key: 'skillId', value: skillId.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of skills for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId The vendor ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {Array<string>} skillId the list of skillIds that you wish to get the summary for. A maximum of 10 skillIds can be specified to get the skill summary in single listSkills call. Please note that this parameter must not be used with &#39;nextToken&#39; or/and &#39;maxResults&#39; parameter.
             */
            SkillManagementServiceClient.prototype.listSkillsForVendorV1 = function (vendorId, nextToken, maxResults, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListSkillsForVendorV1(vendorId, nextToken, maxResults, skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} importId The Import ID.
             */
            SkillManagementServiceClient.prototype.callGetImportStatusV1 = function (importId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetImportStatusV1';
                                // verify required parameter 'importId' is not null or undefined
                                if (importId == null) {
                                    throw new Error("Required parameter importId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('importId', importId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/imports/{importId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "OK.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} importId The Import ID.
             */
            SkillManagementServiceClient.prototype.getImportStatusV1 = function (importId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetImportStatusV1(importId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.CreateSkillWithPackageRequest} createSkillWithPackageRequest Defines the request body for createPackage API.
             */
            SkillManagementServiceClient.prototype.callCreateSkillPackageV1 = function (createSkillWithPackageRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSkillPackageV1';
                                // verify required parameter 'createSkillWithPackageRequest' is not null or undefined
                                if (createSkillWithPackageRequest == null) {
                                    throw new Error("Required parameter createSkillWithPackageRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/imports";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(413, "Payload too large.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createSkillWithPackageRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.CreateSkillWithPackageRequest} createSkillWithPackageRequest Defines the request body for createPackage API.
             */
            SkillManagementServiceClient.prototype.createSkillPackageV1 = function (createSkillWithPackageRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSkillPackageV1(createSkillWithPackageRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.CreateSkillRequest} createSkillRequest Defines the request body for createSkill API.
             */
            SkillManagementServiceClient.prototype.callCreateSkillForVendorV1 = function (createSkillRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateSkillForVendorV1';
                                // verify required parameter 'createSkillRequest' is not null or undefined
                                if (createSkillRequest == null) {
                                    throw new Error("Required parameter createSkillRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted; Returns a URL to track the status in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createSkillRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.CreateSkillRequest} createSkillRequest Defines the request body for createSkill API.
             */
            SkillManagementServiceClient.prototype.createSkillForVendorV1 = function (createSkillRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateSkillForVendorV1(createSkillRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callGetAlexaHostedSkillMetadataV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAlexaHostedSkillMetadataV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/alexaHosted";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "response contains the Alexa hosted skill&#39;s metadata");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. Authorization Url is invalid");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.getAlexaHostedSkillMetadataV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAlexaHostedSkillMetadataV1(skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.AlexaHosted.HostedSkillRepositoryCredentialsRequest} hostedSkillRepositoryCredentialsRequest defines the request body for hosted skill repository credentials
             */
            SkillManagementServiceClient.prototype.callGenerateCredentialsForAlexaHostedSkillV1 = function (skillId, hostedSkillRepositoryCredentialsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGenerateCredentialsForAlexaHostedSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'hostedSkillRepositoryCredentialsRequest' is not null or undefined
                                if (hostedSkillRepositoryCredentialsRequest == null) {
                                    throw new Error("Required parameter hostedSkillRepositoryCredentialsRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/alexaHosted/repository/credentials/generate";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the hosted skill repository credentials");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. Authorization Url is invalid");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, hostedSkillRepositoryCredentialsRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.AlexaHosted.HostedSkillRepositoryCredentialsRequest} hostedSkillRepositoryCredentialsRequest defines the request body for hosted skill repository credentials
             */
            SkillManagementServiceClient.prototype.generateCredentialsForAlexaHostedSkillV1 = function (skillId, hostedSkillRepositoryCredentialsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGenerateCredentialsForAlexaHostedSkillV1(skillId, hostedSkillRepositoryCredentialsRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callEndBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callEndBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest/end";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accept. Return a URL to track the resource in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.endBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callEndBetaTestV1(skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callGetBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.getBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetBetaTestV1(skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.TestBody} createTestBody JSON object containing the details of a beta test used to create the test.
             */
            SkillManagementServiceClient.prototype.callCreateBetaTestV1 = function (skillId, createTestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. Return a URL to track the resource in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createTestBody, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.TestBody} createTestBody JSON object containing the details of a beta test used to create the test.
             */
            SkillManagementServiceClient.prototype.createBetaTestV1 = function (skillId, createTestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateBetaTestV1(skillId, createTestBody)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.TestBody} createTestBody JSON object containing the details of a beta test used to create the test.
             */
            SkillManagementServiceClient.prototype.callUpdateBetaTestV1 = function (skillId, createTestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createTestBody, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.TestBody} createTestBody JSON object containing the details of a beta test used to create the test.
             */
            SkillManagementServiceClient.prototype.updateBetaTestV1 = function (skillId, createTestBody) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateBetaTestV1(skillId, createTestBody)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callStartBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callStartBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest/start";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accept. Return a URL to track the resource in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.startBetaTestV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callStartBetaTestV1(skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.callAddTestersToBetaTestV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callAddTestersToBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'testersRequest' is not null or undefined
                                if (testersRequest == null) {
                                    throw new Error("Required parameter testersRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest/testers/add";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, testersRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.addTestersToBetaTestV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callAddTestersToBetaTestV1(skillId, testersRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callGetListOfTestersV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetListOfTestersV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest/testers";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Success.");
                                errorDefinitions.set(400, "Bad request.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.getListOfTestersV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetListOfTestersV1(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.callRemoveTestersFromBetaTestV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callRemoveTestersFromBetaTestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'testersRequest' is not null or undefined
                                if (testersRequest == null) {
                                    throw new Error("Required parameter testersRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest/testers/remove";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, testersRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.removeTestersFromBetaTestV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callRemoveTestersFromBetaTestV1(skillId, testersRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.callRequestFeedbackFromTestersV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callRequestFeedbackFromTestersV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'testersRequest' is not null or undefined
                                if (testersRequest == null) {
                                    throw new Error("Required parameter testersRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest/testers/requestFeedback";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, testersRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.requestFeedbackFromTestersV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callRequestFeedbackFromTestersV1(skillId, testersRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.callSendReminderToTestersV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSendReminderToTestersV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'testersRequest' is not null or undefined
                                if (testersRequest == null) {
                                    throw new Error("Required parameter testersRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/betaTest/testers/sendReminder";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, testersRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.betaTest.testers.TestersList} testersRequest JSON object containing the email address of beta testers.
             */
            SkillManagementServiceClient.prototype.sendReminderToTestersV1 = function (skillId, testersRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSendReminderToTestersV1(skillId, testersRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} certificationId Id of the certification. Reserved word identifier of mostRecent can be used to get the most recent certification for the skill. Note that the behavior of the API in this case would be the same as when the actual certification id of the most recent certification is used in the request.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.callGetCertificationReviewV1 = function (skillId, certificationId, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetCertificationReviewV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'certificationId' is not null or undefined
                                if (certificationId == null) {
                                    throw new Error("Required parameter certificationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (acceptLanguage != null) {
                                    headerParams.push({ key: 'Accept-Language', value: acceptLanguage });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('certificationId', certificationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/certifications/{certificationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill certification information.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId. ");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} certificationId Id of the certification. Reserved word identifier of mostRecent can be used to get the most recent certification for the skill. Note that the behavior of the API in this case would be the same as when the actual certification id of the most recent certification is used in the request.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.getCertificationReviewV1 = function (skillId, certificationId, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetCertificationReviewV1(skillId, certificationId, acceptLanguage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callGetCertificationsListV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetCertificationsListV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/certifications";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of certifications for the skillId.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. if any request parameter is invalid like certification Id or pagination token etc. If the maxResults is not in the range of 1 to 50, it also qualifies for this error. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeded the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId. ");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.getCertificationsListV1 = function (skillId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetCertificationsListV1(skillId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callGetSkillCredentialsV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillCredentialsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/credentials";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the skill credentials.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.getSkillCredentialsV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillCredentialsV1(skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callDeleteSkillV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.deleteSkillV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteSkillV1(skillId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             * @param {Array<v1.StageType>} stage A filter used to retrieve items where the stage is equal to the given value.
             * @param {Array<v1.skill.history.LocaleInQuery>} locale
             * @param {Array<v1.skill.history.DialogActName>} dialogActName A filter used to retrieve items where the dialogAct name is equal to the given value. * &#x60;Dialog.ElicitSlot&#x60;: Alexa asked the user for the value of a specific slot. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#elicitslot) * &#x60;Dialog.ConfirmSlot&#x60;: Alexa confirmed the value of a specific slot before continuing with the dialog. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#confirmslot) * &#x60;Dialog.ConfirmIntent&#x60;: Alexa confirmed the all the information the user has provided for the intent before the skill took action. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#confirmintent)
             * @param {Array<v1.skill.history.IntentConfidenceBin>} intentConfidenceBin
             * @param {Array<string>} intentName A filter used to retrieve items where the intent name is equal to the given value.
             * @param {Array<string>} intentSlotsName A filter used to retrieve items where the one of the slot names is equal to the given value.
             * @param {Array<v1.skill.history.InteractionType>} interactionType
             * @param {Array<v1.skill.history.PublicationStatus>} publicationStatus
             * @param {Array<string>} utteranceText A filter used to retrieve items where the utterance text contains the given phrase. Each filter value can be at-least 1 character and at-most 100 characters long.
             */
            SkillManagementServiceClient.prototype.callGetUtteranceDataV1 = function (skillId, nextToken, maxResults, sortDirection, sortField, stage, locale, dialogActName, intentConfidenceBin, intentName, intentSlotsName, interactionType, publicationStatus, utteranceText) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetUtteranceDataV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (sortDirection != null) {
                                    queryParams.push({ key: 'sortDirection', value: sortDirection });
                                }
                                if (sortField != null) {
                                    queryParams.push({ key: 'sortField', value: sortField });
                                }
                                if (stage != null) {
                                    queryParams.push({ key: 'stage', value: stage.toString() });
                                }
                                if (locale != null) {
                                    queryParams.push({ key: 'locale', value: locale.toString() });
                                }
                                if (dialogActName != null) {
                                    queryParams.push({ key: 'dialogAct.name', value: dialogActName.toString() });
                                }
                                if (intentConfidenceBin != null) {
                                    queryParams.push({ key: 'intent.confidence.bin', value: intentConfidenceBin.toString() });
                                }
                                if (intentName != null) {
                                    queryParams.push({ key: 'intent.name', value: intentName.toString() });
                                }
                                if (intentSlotsName != null) {
                                    queryParams.push({ key: 'intent.slots.name', value: intentSlotsName.toString() });
                                }
                                if (interactionType != null) {
                                    queryParams.push({ key: 'interactionType', value: interactionType.toString() });
                                }
                                if (publicationStatus != null) {
                                    queryParams.push({ key: 'publicationStatus', value: publicationStatus.toString() });
                                }
                                if (utteranceText != null) {
                                    queryParams.push({ key: 'utteranceText', value: utteranceText.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/history/intentRequests";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns a list of utterance items for the given skill.");
                                errorDefinitions.set(400, "Bad Request.");
                                errorDefinitions.set(401, "Unauthorized.");
                                errorDefinitions.set(404, "Skill Not Found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             * @param {Array<v1.StageType>} stage A filter used to retrieve items where the stage is equal to the given value.
             * @param {Array<v1.skill.history.LocaleInQuery>} locale
             * @param {Array<v1.skill.history.DialogActName>} dialogActName A filter used to retrieve items where the dialogAct name is equal to the given value. * &#x60;Dialog.ElicitSlot&#x60;: Alexa asked the user for the value of a specific slot. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#elicitslot) * &#x60;Dialog.ConfirmSlot&#x60;: Alexa confirmed the value of a specific slot before continuing with the dialog. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#confirmslot) * &#x60;Dialog.ConfirmIntent&#x60;: Alexa confirmed the all the information the user has provided for the intent before the skill took action. (https://developer.amazon.com/docs/custom-skills/dialog-interface-reference.html#confirmintent)
             * @param {Array<v1.skill.history.IntentConfidenceBin>} intentConfidenceBin
             * @param {Array<string>} intentName A filter used to retrieve items where the intent name is equal to the given value.
             * @param {Array<string>} intentSlotsName A filter used to retrieve items where the one of the slot names is equal to the given value.
             * @param {Array<v1.skill.history.InteractionType>} interactionType
             * @param {Array<v1.skill.history.PublicationStatus>} publicationStatus
             * @param {Array<string>} utteranceText A filter used to retrieve items where the utterance text contains the given phrase. Each filter value can be at-least 1 character and at-most 100 characters long.
             */
            SkillManagementServiceClient.prototype.getUtteranceDataV1 = function (skillId, nextToken, maxResults, sortDirection, sortField, stage, locale, dialogActName, intentConfidenceBin, intentName, intentSlotsName, interactionType, publicationStatus, utteranceText) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetUtteranceDataV1(skillId, nextToken, maxResults, sortDirection, sortField, stage, locale, dialogActName, intentConfidenceBin, intentName, intentSlotsName, interactionType, publicationStatus, utteranceText)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.UpdateSkillWithPackageRequest} updateSkillWithPackageRequest Defines the request body for updatePackage API.
             * @param {string} skillId The skill ID.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callImportSkillPackageV1 = function (updateSkillWithPackageRequest, skillId, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callImportSkillPackageV1';
                                // verify required parameter 'updateSkillWithPackageRequest' is not null or undefined
                                if (updateSkillWithPackageRequest == null) {
                                    throw new Error("Required parameter updateSkillWithPackageRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/imports";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(413, "Payload too large.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateSkillWithPackageRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.UpdateSkillWithPackageRequest} updateSkillWithPackageRequest Defines the request body for updatePackage API.
             * @param {string} skillId The skill ID.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.importSkillPackageV1 = function (updateSkillWithPackageRequest, skillId, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callImportSkillPackageV1(updateSkillWithPackageRequest, skillId, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} startTime The start time of query.
             * @param {string} endTime The end time of query (The maximum time duration is 1 week)
             * @param {string} period The aggregation period to use when retrieving the metric, follows ISO_8601#Durations format.
             * @param {string} metric A distinct set of logic which predictably returns a set of data.
             * @param {string} stage The stage of the skill (live, development).
             * @param {string} skillType The type of the skill (custom, smartHome and flashBriefing).
             * @param {string} intent The intent of the skill.
             * @param {string} locale The locale for the skill. e.g. en-GB, en-US, de-DE and etc.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.callGetSkillMetricsV1 = function (skillId, startTime, endTime, period, metric, stage, skillType, intent, locale, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillMetricsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'startTime' is not null or undefined
                                if (startTime == null) {
                                    throw new Error("Required parameter startTime was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'endTime' is not null or undefined
                                if (endTime == null) {
                                    throw new Error("Required parameter endTime was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'period' is not null or undefined
                                if (period == null) {
                                    throw new Error("Required parameter period was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'metric' is not null or undefined
                                if (metric == null) {
                                    throw new Error("Required parameter metric was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillType' is not null or undefined
                                if (skillType == null) {
                                    throw new Error("Required parameter skillType was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                queryParams.push({ key: 'startTime', value: startTime.toString() });
                                queryParams.push({ key: 'endTime', value: endTime.toString() });
                                queryParams.push({ key: 'period', value: period });
                                queryParams.push({ key: 'metric', value: metric });
                                queryParams.push({ key: 'stage', value: stage });
                                queryParams.push({ key: 'skillType', value: skillType });
                                if (intent != null) {
                                    queryParams.push({ key: 'intent', value: intent });
                                }
                                if (locale != null) {
                                    queryParams.push({ key: 'locale', value: locale });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/metrics";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Get analytic metrics report successfully.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} startTime The start time of query.
             * @param {string} endTime The end time of query (The maximum time duration is 1 week)
             * @param {string} period The aggregation period to use when retrieving the metric, follows ISO_8601#Durations format.
             * @param {string} metric A distinct set of logic which predictably returns a set of data.
             * @param {string} stage The stage of the skill (live, development).
             * @param {string} skillType The type of the skill (custom, smartHome and flashBriefing).
             * @param {string} intent The intent of the skill.
             * @param {string} locale The locale for the skill. e.g. en-GB, en-US, de-DE and etc.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             */
            SkillManagementServiceClient.prototype.getSkillMetricsV1 = function (skillId, startTime, endTime, period, metric, stage, skillType, intent, locale, maxResults, nextToken) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillMetricsV1(skillId, startTime, endTime, period, metric, stage, skillType, intent, locale, maxResults, nextToken)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {string} accept Standard HTTP. Pass &#x60;application/json&#x60; or &#x60;test/csv&#x60; for GET calls.
             */
            SkillManagementServiceClient.prototype.callGetAnnotationsForNLUAnnotationSetsV1 = function (skillId, annotationId, accept) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAnnotationsForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'accept' is not null or undefined
                                if (accept == null) {
                                    throw new Error("Required parameter accept was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                headerParams.push({ key: 'Accept', value: accept });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}/annotations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The specific version of a NLU annotation set has the content.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {string} accept Standard HTTP. Pass &#x60;application/json&#x60; or &#x60;test/csv&#x60; for GET calls.
             */
            SkillManagementServiceClient.prototype.getAnnotationsForNLUAnnotationSetsV1 = function (skillId, annotationId, accept) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAnnotationsForNLUAnnotationSetsV1(skillId, annotationId, accept)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {string} contentType Standard HTTP. Pass &#x60;application/json&#x60; or &#x60;test/csv&#x60; for POST calls with a json/csv body.
             * @param {v1.skill.nlu.annotationSets.UpdateNLUAnnotationSetAnnotationsRequest} updateNLUAnnotationSetAnnotationsRequest Payload sent to the update NLU annotation set API.
             */
            SkillManagementServiceClient.prototype.callUpdateAnnotationsForNLUAnnotationSetsV1 = function (skillId, annotationId, contentType, updateNLUAnnotationSetAnnotationsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateAnnotationsForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'contentType' is not null or undefined
                                if (contentType == null) {
                                    throw new Error("Required parameter contentType was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateNLUAnnotationSetAnnotationsRequest' is not null or undefined
                                if (updateNLUAnnotationSetAnnotationsRequest == null) {
                                    throw new Error("Required parameter updateNLUAnnotationSetAnnotationsRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                headerParams.push({ key: 'Content-Type', value: contentType });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}/annotations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "NLU annotation set exists and starts the update.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateNLUAnnotationSetAnnotationsRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {string} contentType Standard HTTP. Pass &#x60;application/json&#x60; or &#x60;test/csv&#x60; for POST calls with a json/csv body.
             * @param {v1.skill.nlu.annotationSets.UpdateNLUAnnotationSetAnnotationsRequest} updateNLUAnnotationSetAnnotationsRequest Payload sent to the update NLU annotation set API.
             */
            SkillManagementServiceClient.prototype.updateAnnotationsForNLUAnnotationSetsV1 = function (skillId, annotationId, contentType, updateNLUAnnotationSetAnnotationsRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateAnnotationsForNLUAnnotationSetsV1(skillId, annotationId, contentType, updateNLUAnnotationSetAnnotationsRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             */
            SkillManagementServiceClient.prototype.callDeletePropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeletePropertiesForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "NLU annotation set exists and is deleted successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             */
            SkillManagementServiceClient.prototype.deletePropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeletePropertiesForNLUAnnotationSetsV1(skillId, annotationId)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             */
            SkillManagementServiceClient.prototype.callGetPropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetPropertiesForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}/properties";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "The NLU annotation set exists.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             */
            SkillManagementServiceClient.prototype.getPropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetPropertiesForNLUAnnotationSetsV1(skillId, annotationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {v1.skill.nlu.annotationSets.UpdateNLUAnnotationSetPropertiesRequest} updateNLUAnnotationSetPropertiesRequest Payload sent to the update NLU annotation set properties API.
             */
            SkillManagementServiceClient.prototype.callUpdatePropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId, updateNLUAnnotationSetPropertiesRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdatePropertiesForNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'annotationId' is not null or undefined
                                if (annotationId == null) {
                                    throw new Error("Required parameter annotationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateNLUAnnotationSetPropertiesRequest' is not null or undefined
                                if (updateNLUAnnotationSetPropertiesRequest == null) {
                                    throw new Error("Required parameter updateNLUAnnotationSetPropertiesRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('annotationId', annotationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluAnnotationSets/{annotationId}/properties";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "NLU annotation set exists and properties are updated successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateNLUAnnotationSetPropertiesRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} annotationId Identifier of the NLU annotation set.
             * @param {v1.skill.nlu.annotationSets.UpdateNLUAnnotationSetPropertiesRequest} updateNLUAnnotationSetPropertiesRequest Payload sent to the update NLU annotation set properties API.
             */
            SkillManagementServiceClient.prototype.updatePropertiesForNLUAnnotationSetsV1 = function (skillId, annotationId, updateNLUAnnotationSetPropertiesRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdatePropertiesForNLUAnnotationSetsV1(skillId, annotationId, updateNLUAnnotationSetPropertiesRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} locale filter to NLU annotation set created using this locale
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 10. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.callListNLUAnnotationSetsV1 = function (skillId, locale, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListNLUAnnotationSetsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (locale != null) {
                                    queryParams.push({ key: 'locale', value: locale });
                                }
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluAnnotationSets";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "NLU annotation sets are returned.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} locale filter to NLU annotation set created using this locale
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 10. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.listNLUAnnotationSetsV1 = function (skillId, locale, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListNLUAnnotationSetsV1(skillId, locale, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.nlu.annotationSets.CreateNLUAnnotationSetRequest} createNLUAnnotationSetRequest Payload sent to the create NLU annotation set API.
             */
            SkillManagementServiceClient.prototype.callCreateNLUAnnotationSetV1 = function (skillId, createNLUAnnotationSetRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateNLUAnnotationSetV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'createNLUAnnotationSetRequest' is not null or undefined
                                if (createNLUAnnotationSetRequest == null) {
                                    throw new Error("Required parameter createNLUAnnotationSetRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluAnnotationSets";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "NLU annotation set created successfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, createNLUAnnotationSetRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.nlu.annotationSets.CreateNLUAnnotationSetRequest} createNLUAnnotationSetRequest Payload sent to the create NLU annotation set API.
             */
            SkillManagementServiceClient.prototype.createNLUAnnotationSetV1 = function (skillId, createNLUAnnotationSetRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateNLUAnnotationSetV1(skillId, createNLUAnnotationSetRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             */
            SkillManagementServiceClient.prototype.callGetNLUEvaluationV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetNLUEvaluationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluEvaluations/{evaluationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation exists and its status is queryable.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             */
            SkillManagementServiceClient.prototype.getNLUEvaluationV1 = function (skillId, evaluationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetNLUEvaluationV1(skillId, evaluationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             * @param {string} sortField
             * @param {string} testCaseStatus only returns test cases with this status
             * @param {string} actualIntentName only returns test cases with intents which resolve to this intent
             * @param {string} expectedIntentName only returns test cases with intents which are expected to be this intent
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.callGetResultForNLUEvaluationsV1 = function (skillId, evaluationId, sortField, testCaseStatus, actualIntentName, expectedIntentName, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetResultForNLUEvaluationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'evaluationId' is not null or undefined
                                if (evaluationId == null) {
                                    throw new Error("Required parameter evaluationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (sortField != null) {
                                    queryParams.push({ key: 'sort.field', value: sortField });
                                }
                                if (testCaseStatus != null) {
                                    queryParams.push({ key: 'testCaseStatus', value: testCaseStatus });
                                }
                                if (actualIntentName != null) {
                                    queryParams.push({ key: 'actualIntentName', value: actualIntentName });
                                }
                                if (expectedIntentName != null) {
                                    queryParams.push({ key: 'expectedIntentName', value: expectedIntentName });
                                }
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('evaluationId', evaluationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluEvaluations/{evaluationId}/results";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation exists and its status is queryable.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} evaluationId Identifier of the evaluation.
             * @param {string} sortField
             * @param {string} testCaseStatus only returns test cases with this status
             * @param {string} actualIntentName only returns test cases with intents which resolve to this intent
             * @param {string} expectedIntentName only returns test cases with intents which are expected to be this intent
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 1000. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.getResultForNLUEvaluationsV1 = function (skillId, evaluationId, sortField, testCaseStatus, actualIntentName, expectedIntentName, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetResultForNLUEvaluationsV1(skillId, evaluationId, sortField, testCaseStatus, actualIntentName, expectedIntentName, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} locale filter to evaluations started using this locale
             * @param {string} stage filter to evaluations started using this stage
             * @param {string} annotationId filter to evaluations started using this annotationId
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 10. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.callListNLUEvaluationsV1 = function (skillId, locale, stage, annotationId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListNLUEvaluationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (locale != null) {
                                    queryParams.push({ key: 'locale', value: locale });
                                }
                                if (stage != null) {
                                    queryParams.push({ key: 'stage', value: stage });
                                }
                                if (annotationId != null) {
                                    queryParams.push({ key: 'annotationId', value: annotationId });
                                }
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluEvaluations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluations are returned.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} locale filter to evaluations started using this locale
             * @param {string} stage filter to evaluations started using this stage
             * @param {string} annotationId filter to evaluations started using this annotationId
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 10. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.listNLUEvaluationsV1 = function (skillId, locale, stage, annotationId, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListNLUEvaluationsV1(skillId, locale, stage, annotationId, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.nlu.evaluations.EvaluateNLURequest} evaluateNLURequest Payload sent to the evaluate NLU API.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callCreateNLUEvaluationsV1 = function (evaluateNLURequest, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateNLUEvaluationsV1';
                                // verify required parameter 'evaluateNLURequest' is not null or undefined
                                if (evaluateNLURequest == null) {
                                    throw new Error("Required parameter evaluateNLURequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/nluEvaluations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Evaluation has successfully begun.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, evaluateNLURequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.nlu.evaluations.EvaluateNLURequest} evaluateNLURequest Payload sent to the evaluate NLU API.
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.createNLUEvaluationsV1 = function (evaluateNLURequest, skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateNLUEvaluationsV1(evaluateNLURequest, skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.simulations.SimulationsApiRequest} simulationsApiRequest Payload sent to the skill simulation API.
             */
            SkillManagementServiceClient.prototype.callSimulateSkillV1 = function (skillId, simulationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSimulateSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'simulationsApiRequest' is not null or undefined
                                if (simulationsApiRequest == null) {
                                    throw new Error("Required parameter simulationsApiRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/simulations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Skill simulation has successfully began.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission to call this API or is currently in a state that does not allow simulation of this skill. ");
                                errorDefinitions.set(404, "The specified skill does not exist.");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, simulationsApiRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.simulations.SimulationsApiRequest} simulationsApiRequest Payload sent to the skill simulation API.
             */
            SkillManagementServiceClient.prototype.simulateSkillV1 = function (skillId, simulationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSimulateSkillV1(skillId, simulationsApiRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} simulationId Id of the simulation.
             */
            SkillManagementServiceClient.prototype.callGetSkillSimulationV1 = function (skillId, simulationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillSimulationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'simulationId' is not null or undefined
                                if (simulationId == null) {
                                    throw new Error("Required parameter simulationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('simulationId', simulationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/simulations/{simulationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill simulation information.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill or simulation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} simulationId Id of the simulation.
             */
            SkillManagementServiceClient.prototype.getSkillSimulationV1 = function (skillId, simulationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillSimulationV1(skillId, simulationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.callGetSSLCertificatesV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSSLCertificatesV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/sslCertificateSets/~latest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the latest version of the ssl certificates.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             */
            SkillManagementServiceClient.prototype.getSSLCertificatesV1 = function (skillId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSSLCertificatesV1(skillId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.SSLCertificatePayload} sslCertificatePayload Defines the input/output of the ssl certificates api for a skill.
             */
            SkillManagementServiceClient.prototype.callSetSSLCertificatesV1 = function (skillId, sslCertificatePayload) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetSSLCertificatesV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'sslCertificatePayload' is not null or undefined
                                if (sslCertificatePayload == null) {
                                    throw new Error("Required parameter sslCertificatePayload was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/sslCertificateSets/~latest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Accepted; Request was successful and get will now result in the new values.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, sslCertificatePayload, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.SSLCertificatePayload} sslCertificatePayload Defines the input/output of the ssl certificates api for a skill.
             */
            SkillManagementServiceClient.prototype.setSSLCertificatesV1 = function (skillId, sslCertificatePayload) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetSSLCertificatesV1(skillId, sslCertificatePayload)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callDeleteSkillEnablementV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteSkillEnablementV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/enablement";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that enablement is successfully deleted.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.deleteSkillEnablementV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteSkillEnablementV1(skillId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callGetSkillEnablementStatusV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillEnablementStatusV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/enablement";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that enablement resource exists for given skillId &amp; stage.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.getSkillEnablementStatusV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillEnablementStatusV1(skillId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callSetSkillEnablementV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetSkillEnablementV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/enablement";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "No Content; Confirms that enablement is successfully created/updated.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.setSkillEnablementV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetSkillEnablementV1(skillId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callCreateExportRequestForSkillV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateExportRequestForSkillV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/exports";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.createExportRequestForSkillV1 = function (skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateExportRequestForSkillV1(skillId, stage)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callGetIspListForSkillIdV1 = function (skillId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetIspListForSkillIdV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/inSkillProducts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains list of in-skill products for the specified skillId and stage.");
                                errorDefinitions.set(400, "Bad request. Returned when a required parameter is not present, badly formatted. ");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(404, "Requested resource not found.");
                                errorDefinitions.set(429, "Too many requests received.");
                                errorDefinitions.set(500, "Internal Server Error");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.getIspListForSkillIdV1 = function (skillId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetIspListForSkillIdV1(skillId, stage, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.evaluations.ProfileNluRequest} profileNluRequest Payload sent to the profile nlu API.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.callProfileNluV1 = function (profileNluRequest, skillId, stage, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callProfileNluV1';
                                // verify required parameter 'profileNluRequest' is not null or undefined
                                if (profileNluRequest == null) {
                                    throw new Error("Required parameter profileNluRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/interactionModel/locales/{locale}/profileNlu";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Profiled utterance against interaction model and returned nlu response successfully.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, profileNluRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.evaluations.ProfileNluRequest} profileNluRequest Payload sent to the profile nlu API.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.profileNluV1 = function (profileNluRequest, skillId, stage, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callProfileNluV1(profileNluRequest, skillId, stage, locale)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} stage Stage of the interaction model.
             * @param {string} version Version of interaction model. Use \&quot;~current\&quot; to get the model of the current version.
             */
            SkillManagementServiceClient.prototype.callGetConflictDetectionJobStatusForInteractionModelV1 = function (skillId, locale, stage, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetConflictDetectionJobStatusForInteractionModelV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('locale', locale);
                                pathParams.set('stage', stage);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/interactionModel/locales/{locale}/versions/{version}/conflictDetectionJobStatus";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Get conflict detection results sucessfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} stage Stage of the interaction model.
             * @param {string} version Version of interaction model. Use \&quot;~current\&quot; to get the model of the current version.
             */
            SkillManagementServiceClient.prototype.getConflictDetectionJobStatusForInteractionModelV1 = function (skillId, locale, stage, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetConflictDetectionJobStatusForInteractionModelV1(skillId, locale, stage, version)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} stage Stage of the interaction model.
             * @param {string} version Version of interaction model. Use \&quot;~current\&quot; to get the model of the current version.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 100. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.callGetConflictsForInteractionModelV1 = function (skillId, locale, stage, version, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetConflictsForInteractionModelV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('locale', locale);
                                pathParams.set('stage', stage);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/interactionModel/locales/{locale}/versions/{version}/conflicts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Get conflict detection results sucessfully.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "There is no catalog defined for the catalogId.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} stage Stage of the interaction model.
             * @param {string} version Version of interaction model. Use \&quot;~current\&quot; to get the model of the current version.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. Defaults to 100. If more results are present, the response will contain a nextToken and a _link.next href.
             */
            SkillManagementServiceClient.prototype.getConflictsForInteractionModelV1 = function (skillId, locale, stage, version, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetConflictsForInteractionModelV1(skillId, locale, stage, version, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.callListPrivateDistributionAccountsV1 = function (skillId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListPrivateDistributionAccountsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/privateDistributionAccounts";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of private distribution accounts on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             */
            SkillManagementServiceClient.prototype.listPrivateDistributionAccountsV1 = function (skillId, stage, nextToken, maxResults) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListPrivateDistributionAccountsV1(skillId, stage, nextToken, maxResults)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} id ARN that a skill can be privately distributed to.
             */
            SkillManagementServiceClient.prototype.callDeletePrivateDistributionAccountIdV1 = function (skillId, stage, id) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeletePrivateDistributionAccountIdV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'id' is not null or undefined
                                if (id == null) {
                                    throw new Error("Required parameter id was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                pathParams.set('id', id);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/privateDistributionAccounts/{id}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} id ARN that a skill can be privately distributed to.
             */
            SkillManagementServiceClient.prototype.deletePrivateDistributionAccountIdV1 = function (skillId, stage, id) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeletePrivateDistributionAccountIdV1(skillId, stage, id)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} id ARN that a skill can be privately distributed to.
             */
            SkillManagementServiceClient.prototype.callSetPrivateDistributionAccountIdV1 = function (skillId, stage, id) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetPrivateDistributionAccountIdV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'id' is not null or undefined
                                if (id == null) {
                                    throw new Error("Required parameter id was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                pathParams.set('id', id);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/privateDistributionAccounts/{id}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} id ARN that a skill can be privately distributed to.
             */
            SkillManagementServiceClient.prototype.setPrivateDistributionAccountIdV1 = function (skillId, stage, id) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetPrivateDistributionAccountIdV1(skillId, stage, id)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.callDeleteAccountLinkingInfoV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callDeleteAccountLinkingInfoV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/accountLinkingClient";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. No content.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill/stage/accountLinkingClient doesn&#39;t exist.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("DELETE", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.deleteAccountLinkingInfoV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callDeleteAccountLinkingInfoV1(skillId, stageV2)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.callGetAccountLinkingInfoV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAccountLinkingInfoV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/accountLinkingClient";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns AccountLinking response of the skill.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.getAccountLinkingInfoV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAccountLinkingInfoV1(skillId, stageV2)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {v1.skill.accountLinking.AccountLinkingRequest} accountLinkingRequest The fields required to create accountLinking partner.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callUpdateAccountLinkingInfoV1 = function (skillId, stageV2, accountLinkingRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateAccountLinkingInfoV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'accountLinkingRequest' is not null or undefined
                                if (accountLinkingRequest == null) {
                                    throw new Error("Required parameter accountLinkingRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/accountLinkingClient";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. Authorization Url is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, accountLinkingRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {v1.skill.accountLinking.AccountLinkingRequest} accountLinkingRequest The fields required to create accountLinking partner.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.updateAccountLinkingInfoV1 = function (skillId, stageV2, accountLinkingRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateAccountLinkingInfoV1(skillId, stageV2, accountLinkingRequest, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelV1 = function (skillId, stageV2, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns interaction model object on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill doesn&#39;t exist or there is no model defined for the locale.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.getInteractionModelV1 = function (skillId, stageV2, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelV1(skillId, stageV2, locale)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelMetadataV1 = function (skillId, stageV2, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelMetadataV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success. There is no content but returns etag.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill or stage or locale does not exist");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("HEAD", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             */
            SkillManagementServiceClient.prototype.getInteractionModelMetadataV1 = function (skillId, stageV2, locale) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelMetadataV1(skillId, stageV2, locale)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {v1.skill.interactionModel.InteractionModelData} interactionModel
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callSetInteractionModelV1 = function (skillId, stageV2, locale, interactionModel, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSetInteractionModelV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'interactionModel' is not null or undefined
                                if (interactionModel == null) {
                                    throw new Error("Required parameter interactionModel was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Returns build status location link on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the input interaction model is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill or stage or locale does not exist.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, interactionModel, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {v1.skill.interactionModel.InteractionModelData} interactionModel
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.setInteractionModelV1 = function (skillId, stageV2, locale, interactionModel, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSetInteractionModelV1(skillId, stageV2, locale, interactionModel, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             */
            SkillManagementServiceClient.prototype.callListInteractionModelVersionsV1 = function (skillId, stageV2, locale, nextToken, maxResults, sortDirection, sortField) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callListInteractionModelVersionsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (nextToken != null) {
                                    queryParams.push({ key: 'nextToken', value: nextToken });
                                }
                                if (maxResults != null) {
                                    queryParams.push({ key: 'maxResults', value: maxResults.toString() });
                                }
                                if (sortDirection != null) {
                                    queryParams.push({ key: 'sortDirection', value: sortDirection });
                                }
                                if (sortField != null) {
                                    queryParams.push({ key: 'sortField', value: sortField });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}/versions";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns list of interactionModel versions of a skill for the vendor.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the input interaction model is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill doesn&#39;t exist or there is no model defined for the locale.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element. The value of nextToken can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that Skill Management API understands. Token has expiry of 24 hours.
             * @param {number} maxResults Sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 50 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned, the response contains isTruncated &#x3D; true.
             * @param {string} sortDirection Sets the sorting direction of the result items. When set to &#39;asc&#39; these items are returned in ascending order of sortField value and when set to &#39;desc&#39; these items are returned in descending order of sortField value.
             * @param {string} sortField Sets the field on which the sorting would be applied.
             */
            SkillManagementServiceClient.prototype.listInteractionModelVersionsV1 = function (skillId, stageV2, locale, nextToken, maxResults, sortDirection, sortField) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callListInteractionModelVersionsV1(skillId, stageV2, locale, nextToken, maxResults, sortDirection, sortField)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.callGetInteractionModelVersionV1 = function (skillId, stageV2, locale, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetInteractionModelVersionV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'locale' is not null or undefined
                                if (locale == null) {
                                    throw new Error("Required parameter locale was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'version' is not null or undefined
                                if (version == null) {
                                    throw new Error("Required parameter version was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                pathParams.set('locale', locale);
                                pathParams.set('version', version);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/interactionModel/locales/{locale}/versions/{version}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns interaction model object on success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. the input interaction model is invalid.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The specified skill doesn&#39;t exist or there is no model defined for the locale or version.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {string} locale The locale for the model requested e.g. en-GB, en-US, de-DE.
             * @param {string} version Version for interaction model.
             */
            SkillManagementServiceClient.prototype.getInteractionModelVersionV1 = function (skillId, stageV2, locale, version) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetInteractionModelVersionV1(skillId, stageV2, locale, version)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.callGetSkillManifestV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillManifestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/manifest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Response contains the latest version of skill manifest.");
                                errorDefinitions.set(303, "See Other");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             */
            SkillManagementServiceClient.prototype.getSkillManifestV1 = function (skillId, stageV2) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillManifestV1(skillId, stageV2)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {v1.skill.Manifest.SkillManifestEnvelope} updateSkillRequest Defines the request body for updateSkill API.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.callUpdateSkillManifestV1 = function (skillId, stageV2, updateSkillRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callUpdateSkillManifestV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stageV2' is not null or undefined
                                if (stageV2 == null) {
                                    throw new Error("Required parameter stageV2 was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'updateSkillRequest' is not null or undefined
                                if (updateSkillRequest == null) {
                                    throw new Error("Required parameter updateSkillRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (ifMatch != null) {
                                    headerParams.push({ key: 'If-Match', value: ifMatch });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stageV2', stageV2);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stageV2}/manifest";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Accepted; Returns a URL to track the status in &#39;Location&#39; header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(409, "The request could not be completed due to a conflict with the current state of the target resource.");
                                errorDefinitions.set(412, "Precondition failed.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("PUT", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, updateSkillRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stageV2 Stages of a skill including the new certified stage. * &#x60;development&#x60; - skills which are currently in development corresponds to this stage. * &#x60;certified&#x60; -  skills which have completed certification and ready for publishing corresponds to this stage. * &#x60;live&#x60; - skills which are currently live corresponds to this stage.
             * @param {v1.skill.Manifest.SkillManifestEnvelope} updateSkillRequest Defines the request body for updateSkill API.
             * @param {string} ifMatch Request header that specified an entity tag. The server will update the resource only if the eTag matches with the resource&#39;s current eTag.
             */
            SkillManagementServiceClient.prototype.updateSkillManifestV1 = function (skillId, stageV2, updateSkillRequest, ifMatch) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callUpdateSkillManifestV1(skillId, stageV2, updateSkillRequest, ifMatch)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.validations.ValidationsApiRequest} validationsApiRequest Payload sent to the skill validation API.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.callSubmitSkillValidationV1 = function (validationsApiRequest, skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSubmitSkillValidationV1';
                                // verify required parameter 'validationsApiRequest' is not null or undefined
                                if (validationsApiRequest == null) {
                                    throw new Error("Required parameter validationsApiRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/validations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Skill validation has successfully begun.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, stage or validation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, validationsApiRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {v1.skill.validations.ValidationsApiRequest} validationsApiRequest Payload sent to the skill validation API.
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             */
            SkillManagementServiceClient.prototype.submitSkillValidationV1 = function (validationsApiRequest, skillId, stage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSubmitSkillValidationV1(validationsApiRequest, skillId, stage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} validationId Id of the validation. Reserved word identifier of mostRecent can be used to get the most recent validation for the skill and stage. Note that the behavior of the API in this case would be the same as when the actual validation id of the most recent validation is used in the request.
             * @param {string} stage Stage for skill.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.callGetSkillValidationsV1 = function (skillId, validationId, stage, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillValidationsV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'validationId' is not null or undefined
                                if (validationId == null) {
                                    throw new Error("Required parameter validationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                if (acceptLanguage != null) {
                                    headerParams.push({ key: 'Accept-Language', value: acceptLanguage });
                                }
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('validationId', validationId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/stages/{stage}/validations/{validationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill validation information.");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill, stage, or validation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} validationId Id of the validation. Reserved word identifier of mostRecent can be used to get the most recent validation for the skill and stage. Note that the behavior of the API in this case would be the same as when the actual validation id of the most recent validation is used in the request.
             * @param {string} stage Stage for skill.
             * @param {string} acceptLanguage User&#39;s locale/language in context.
             */
            SkillManagementServiceClient.prototype.getSkillValidationsV1 = function (skillId, validationId, stage, acceptLanguage) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillValidationsV1(skillId, validationId, stage, acceptLanguage)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} resource Resource name for which status information is desired. It is an optional, filtering parameter and can be used more than once, to retrieve status for all the desired (sub)resources only, in single API call. If this parameter is not specified, status for all the resources/sub-resources will be returned.
             */
            SkillManagementServiceClient.prototype.callGetSkillStatusV1 = function (skillId, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillStatusV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                if (resource != null) {
                                    queryParams.push({ key: 'resource', value: resource });
                                }
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/status";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Returns status for skill resource and sub-resources.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} resource Resource name for which status information is desired. It is an optional, filtering parameter and can be used more than once, to retrieve status for all the desired (sub)resources only, in single API call. If this parameter is not specified, status for all the resources/sub-resources will be returned.
             */
            SkillManagementServiceClient.prototype.getSkillStatusV1 = function (skillId, resource) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillStatusV1(skillId, resource)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.SubmitSkillForCertificationRequest} submitSkillForCertificationRequest Defines the request body for submitSkillForCertification API.
             */
            SkillManagementServiceClient.prototype.callSubmitSkillForCertificationV1 = function (skillId, submitSkillForCertificationRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSubmitSkillForCertificationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/submit";
                                errorDefinitions = new Map();
                                errorDefinitions.set(202, "Success. There is no content but returns Location in the header.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, submitSkillForCertificationRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.SubmitSkillForCertificationRequest} submitSkillForCertificationRequest Defines the request body for submitSkillForCertification API.
             */
            SkillManagementServiceClient.prototype.submitSkillForCertificationV1 = function (skillId, submitSkillForCertificationRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSubmitSkillForCertificationV1(skillId, submitSkillForCertificationRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.WithdrawRequest} withdrawRequest The reason and message (in case of OTHER) to withdraw a skill.
             */
            SkillManagementServiceClient.prototype.callWithdrawSkillFromCertificationV1 = function (skillId, withdrawRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callWithdrawSkillFromCertificationV1';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'withdrawRequest' is not null or undefined
                                if (withdrawRequest == null) {
                                    throw new Error("Required parameter withdrawRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/{skillId}/withdraw";
                                errorDefinitions = new Map();
                                errorDefinitions.set(204, "Success.");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "The operation being requested is not allowed.");
                                errorDefinitions.set(404, "The resource being requested is not found.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, withdrawRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {v1.skill.WithdrawRequest} withdrawRequest The reason and message (in case of OTHER) to withdraw a skill.
             */
            SkillManagementServiceClient.prototype.withdrawSkillFromCertificationV1 = function (skillId, withdrawRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callWithdrawSkillFromCertificationV1(skillId, withdrawRequest)];
                            case 1:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                });
            };
            /**
             *
             */
            SkillManagementServiceClient.prototype.callCreateUploadUrlV1 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callCreateUploadUrlV1';
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/skills/uploads";
                                errorDefinitions = new Map();
                                errorDefinitions.set(201, "Created.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceeds the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             */
            SkillManagementServiceClient.prototype.createUploadUrlV1 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callCreateUploadUrlV1()];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             */
            SkillManagementServiceClient.prototype.callGetVendorListV1 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetVendorListV1';
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/vendors";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Return vendor information on success.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             */
            SkillManagementServiceClient.prototype.getVendorListV1 = function () {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetVendorListV1()];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId vendorId
             * @param {string} permission The permission of a hosted skill feature that customer needs to check.
             */
            SkillManagementServiceClient.prototype.callGetAlexaHostedSkillUserPermissionsV1 = function (vendorId, permission) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetAlexaHostedSkillUserPermissionsV1';
                                // verify required parameter 'vendorId' is not null or undefined
                                if (vendorId == null) {
                                    throw new Error("Required parameter vendorId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'permission' is not null or undefined
                                if (permission == null) {
                                    throw new Error("Required parameter permission was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('vendorId', vendorId);
                                pathParams.set('permission', permission);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v1/vendors/{vendorId}/alexaHosted/permissions/{permission}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "response contains the user&#39;s permission of hosted skill features");
                                errorDefinitions.set(400, "Server cannot process the request due to a client error e.g. Authorization Url is invalid");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(429, "Exceed the permitted request limit. Throttling criteria includes total requests, per API, ClientId, and CustomerId.");
                                errorDefinitions.set(500, "Internal Server Error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} vendorId vendorId
             * @param {string} permission The permission of a hosted skill feature that customer needs to check.
             */
            SkillManagementServiceClient.prototype.getAlexaHostedSkillUserPermissionsV1 = function (vendorId, permission) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetAlexaHostedSkillUserPermissionsV1(vendorId, permission)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {v2.skill.invocations.InvocationsApiRequest} invocationsApiRequest Payload sent to the skill invocation API.
             */
            SkillManagementServiceClient.prototype.callInvokeSkillEndPointV2 = function (skillId, stage, invocationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callInvokeSkillEndPointV2';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'invocationsApiRequest' is not null or undefined
                                if (invocationsApiRequest == null) {
                                    throw new Error("Required parameter invocationsApiRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v2/skills/{skillId}/stages/{stage}/invocations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Skill was invoked.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission to call this API or is currently in a state that does not allow invocation of this skill. ");
                                errorDefinitions.set(404, "The specified skill does not exist.");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, invocationsApiRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {v2.skill.invocations.InvocationsApiRequest} invocationsApiRequest Payload sent to the skill invocation API.
             */
            SkillManagementServiceClient.prototype.invokeSkillEndPointV2 = function (skillId, stage, invocationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callInvokeSkillEndPointV2(skillId, stage, invocationsApiRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {v2.skill.simulations.SimulationsApiRequest} simulationsApiRequest Payload sent to the skill simulation API.
             */
            SkillManagementServiceClient.prototype.callSimulateSkillV2 = function (skillId, stage, simulationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callSimulateSkillV2';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'simulationsApiRequest' is not null or undefined
                                if (simulationsApiRequest == null) {
                                    throw new Error("Required parameter simulationsApiRequest was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'Content-type', value: 'application/json' });
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v2/skills/{skillId}/stages/{stage}/simulations";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Skill simulation has successfully began.");
                                errorDefinitions.set(400, "Bad request due to invalid or missing data.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission to call this API or is currently in a state that does not allow simulation of this skill. ");
                                errorDefinitions.set(404, "The specified skill does not exist.");
                                errorDefinitions.set(409, "This requests conflicts with another one currently being processed. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("POST", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, simulationsApiRequest, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {v2.skill.simulations.SimulationsApiRequest} simulationsApiRequest Payload sent to the skill simulation API.
             */
            SkillManagementServiceClient.prototype.simulateSkillV2 = function (skillId, stage, simulationsApiRequest) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callSimulateSkillV2(skillId, stage, simulationsApiRequest)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} simulationId Id of the simulation.
             */
            SkillManagementServiceClient.prototype.callGetSkillSimulationV2 = function (skillId, stage, simulationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var __operationId__, queryParams, headerParams, pathParams, accessToken, authorizationValue, path, errorDefinitions;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                __operationId__ = 'callGetSkillSimulationV2';
                                // verify required parameter 'skillId' is not null or undefined
                                if (skillId == null) {
                                    throw new Error("Required parameter skillId was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'stage' is not null or undefined
                                if (stage == null) {
                                    throw new Error("Required parameter stage was null or undefined when calling " + __operationId__ + ".");
                                }
                                // verify required parameter 'simulationId' is not null or undefined
                                if (simulationId == null) {
                                    throw new Error("Required parameter simulationId was null or undefined when calling " + __operationId__ + ".");
                                }
                                queryParams = [];
                                headerParams = [];
                                headerParams.push({ key: 'User-Agent', value: this.userAgent });
                                pathParams = new Map();
                                pathParams.set('skillId', skillId);
                                pathParams.set('stage', stage);
                                pathParams.set('simulationId', simulationId);
                                return [4 /*yield*/, this.lwaServiceClient.getAccessToken()];
                            case 1:
                                accessToken = _a.sent();
                                authorizationValue = "Bearer " + accessToken;
                                headerParams.push({ key: "Authorization", value: authorizationValue });
                                path = "/v2/skills/{skillId}/stages/{stage}/simulations/{simulationId}";
                                errorDefinitions = new Map();
                                errorDefinitions.set(200, "Successfully retrieved skill simulation information.");
                                errorDefinitions.set(401, "The auth token is invalid/expired or doesn&#39;t have access to the resource.");
                                errorDefinitions.set(403, "API user does not have permission or is currently in a state that does not allow calls to this API. ");
                                errorDefinitions.set(404, "The specified skill or simulation does not exist. The error response will contain a description that indicates the specific resource type that was not found. ");
                                errorDefinitions.set(429, "API user has exceeded the permitted request rate.");
                                errorDefinitions.set(500, "Internal service error.");
                                errorDefinitions.set(503, "Service Unavailable.");
                                return [2 /*return*/, this.invoke("GET", this.apiConfiguration.apiEndpoint, path, pathParams, queryParams, headerParams, null, errorDefinitions)];
                        }
                    });
                });
            };
            /**
             *
             * @param {string} skillId The skill ID.
             * @param {string} stage Stage for skill.
             * @param {string} simulationId Id of the simulation.
             */
            SkillManagementServiceClient.prototype.getSkillSimulationV2 = function (skillId, stage, simulationId) {
                return __awaiter(this, void 0, void 0, function () {
                    var apiResponse;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, this.callGetSkillSimulationV2(skillId, stage, simulationId)];
                            case 1:
                                apiResponse = _a.sent();
                                return [2 /*return*/, apiResponse.body];
                        }
                    });
                });
            };
            return SkillManagementServiceClient;
        }(BaseServiceClient));
        skillManagement.SkillManagementServiceClient = SkillManagementServiceClient;
    })(skillManagement = services.skillManagement || (services.skillManagement = {}));
})(services = exports.services || (exports.services = {}));
(function (services) {
    /**
     * Helper class that instantiates an ServiceClient implementation automatically resolving its
     * required ApiConfiguration.
     * @export
     * @class ServiceClientFactory
     */
    var ServiceClientFactory = /** @class */ (function () {
        function ServiceClientFactory(apiConfiguration) {
            this.apiConfiguration = apiConfiguration;
        }
        return ServiceClientFactory;
    }());
    services.ServiceClientFactory = ServiceClientFactory;
})(services = exports.services || (exports.services = {}));
//# sourceMappingURL=index.js.map